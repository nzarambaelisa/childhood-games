import React, { useState, useEffect, useCallback, useRef } from 'react';\nimport { useParams } from 'react-router-dom';\nimport { useGameContext } from '../contexts/GameContext';\nimport socketService from '../services/socketService';\n\ntype Position = {\n  x: number;\n  y: number;\n};\n\ntype Direction = {\n  x: number;\n  y: number;\n};\n\nconst GRID_SIZE = 20;\nconst CELL_SIZE = 20;\nconst INITIAL_SNAKE = [{ x: 10, y: 10 }];\nconst INITIAL_DIRECTION: Direction = { x: 1, y: 0 };\nconst GAME_SPEED = 150;\n\ninterface GameState {\n  snake: Position[];\n  food: Position;\n  direction: Direction;\n  score: number;\n}\n\nconst SnakeGame: React.FC = () => {\n  const { gameId } = useParams<{ gameId: string }>();\n  const { currentGame, setCurrentGame } = useGameContext();\n  const [gameState, setGameState] = useState<GameState>({\n    snake: INITIAL_SNAKE,\n    food: { x: 15, y: 15 },\n    direction: INITIAL_DIRECTION,\n    score: 0\n  });\n  const [isMultiplayer, setIsMultiplayer] = useState(false);\n  const [isGameOver, setIsGameOver] = useState(false);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const audioContextRef = useRef<AudioContext | null>(null);\n  const directionRef = useRef<Direction>(INITIAL_DIRECTION);\n\n  useEffect(() => {\n    if (gameId) {\n      setCurrentGame(gameId);\n    }\n  }, [gameId, setCurrentGame]);\n\n  useEffect(() => {\n    if (isMultiplayer) {\n      socketService.connect();\n      socketService.socket?.on('game_state_update', (newState: GameState) => {\n        setGameState(newState);\n      });\n      return () => {\n        socketService.disconnect();\n      };\n    }\n  }, [isMultiplayer]);\n\n  const initializeAudio = () => {\n    if (!audioContextRef.current) {\n      audioContextRef.current = new (window.AudioContext || (window as any).webkitAudioContext)();\n    }\n  };\n\n  const playPointSound = () => {\n    if (!audioContextRef.current) return;\n\n    const audioContext = audioContextRef.current;\n    const oscillator = audioContext.createOscillator();\n    const gainNode = audioContext.createGain();\n\n    oscillator.connect(gainNode);\n    gainNode.connect(audioContext.destination);\n\n    oscillator.type = 'sine';\n    oscillator.frequency.setValueAtTime(660, audioContext.currentTime);\n    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);\n\n    oscillator.start();\n    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);\n    setTimeout(() => oscillator.stop(), 100);\n  };\n\n  const generateFood = useCallback(() => {\n    const newFood = {\n      x: Math.floor(Math.random() * GRID_SIZE),\n      y: Math.floor(Math.random() * GRID_SIZE),\n    };\n    if (gameState.snake.some(segment => segment.x === newFood.x && segment.y === newFood.y)) {\n      return generateFood();\n    }\n    setGameState(prev => ({ ...prev, food: newFood }));\n  }, [gameState.snake]);\n\n  const resetGame = () => {\n    initializeAudio();\n    setGameState({\n      snake: INITIAL_SNAKE,\n      food: { x: 15, y: 15 },\n      direction: INITIAL_DIRECTION,\n      score: 0\n    });\n    directionRef.current = INITIAL_DIRECTION;\n    setIsGameOver(false);\n    setIsPlaying(true);\n    generateFood();\n  };\n\n  const wrapPosition = (pos: number): number => {\n    if (pos < 0) return GRID_SIZE - 1;\n    if (pos >= GRID_SIZE) return 0;\n    return pos;\n  };\n\n  const checkCollision = (head: Position, snakeBody: Position[]): boolean => {\n    return snakeBody.slice(1).some(segment => segment.x === head.x && segment.y === head.y);\n  };\n\n  const moveSnake = useCallback(() => {\n    if (!isPlaying || isGameOver) return;\n\n    setGameState(prev => {\n      const newSnake = [...prev.snake];\n      const direction = directionRef.current;\n      \n      const head = {\n        x: wrapPosition(newSnake[0].x + direction.x),\n        y: wrapPosition(newSnake[0].y + direction.y),\n      };\n\n      newSnake.unshift(head);\n\n      if (checkCollision(head, newSnake)) {\n        setIsGameOver(true);\n        setIsPlaying(false);\n        return prev;\n      }\n\n      if (head.x === prev.food.x && head.y === prev.food.y) {\n        playPointSound();\n        generateFood();\n        return {\n          ...prev,\n          snake: newSnake,\n          score: prev.score + 1\n        };\n      }\n\n      newSnake.pop();\n      return {\n        ...prev,\n        snake: newSnake\n      };\n    });\n  }, [isGameOver, isPlaying, generateFood]);\n\n  useEffect(() => {\n    const handleKeyPress = (e: KeyboardEvent) => {\n      if (!isPlaying) return;\n      \n      if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {\n        e.preventDefault();\n      }\n      \n      const currentDirection = directionRef.current;\n      \n      switch (e.key) {\n        case 'ArrowUp':\n          if (currentDirection.y !== 1) {\n            directionRef.current = { x: 0, y: -1 };\n          }\n          break;\n        case 'ArrowDown':\n          if (currentDirection.y !== -1) {\n            directionRef.current = { x: 0, y: 1 };\n          }\n          break;\n        case 'ArrowLeft':\n          if (currentDirection.x !== 1) {\n            directionRef.current = { x: -1, y: 0 };\n          }\n          break;\n        case 'ArrowRight':\n          if (currentDirection.x !== -1) {\n            directionRef.current = { x: 1, y: 0 };\n          }\n          break;\n      }\n    };\n\n    window.addEventListener('keydown', handleKeyPress);\n    return () => window.removeEventListener('keydown', handleKeyPress);\n  }, [isPlaying]);\n\n  useEffect(() => {\n    const gameLoop = setInterval(moveSnake, GAME_SPEED);\n    return () => clearInterval(gameLoop);\n  }, [moveSnake]);\n\n  return (\n    <div className=\"max-w-4xl mx-auto px-4 py-8\">\n      <div className=\"bg-white rounded-lg shadow-lg p-6\">\n        <div className=\"mb-4 flex justify-between items-center\">\n          <h2 className=\"text-2xl font-bold\">Snake Game</h2>\n          <div className=\"text-lg\">Score: {gameState.score}</div>\n        </div>\n\n        <div className=\"border-2 border-gray-300 relative\" style={{ width: '400px', height: '400px' }}>\n          {gameState.snake.map((segment, index) => (\n            <div\n              key={index}\n              className=\"absolute bg-green-500 rounded-sm\"\n              style={{\n                width: CELL_SIZE - 2,\n                height: CELL_SIZE - 2,\n                left: segment.x * CELL_SIZE,\n                top: segment.y * CELL_SIZE,\n              }}\n            />\n          ))}\n          <div\n            className=\"absolute bg-red-500 rounded-full\"\n            style={{\n              width: CELL_SIZE - 2,\n              height: CELL_SIZE - 2,\n              left: gameState.food.x * CELL_SIZE,\n              top: gameState.food.y * CELL_SIZE,\n            }}\n          />\n          {isGameOver && (\n            <div className=\"absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center\">\n              <div className=\"text-white text-2xl font-bold\">Game Over!</div>\n            </div>\n          )}\n          {!isPlaying && !isGameOver && (\n            <div className=\"absolute inset-0 bg-black bg-opacity-50 flex items-center justify-center\">\n              <div className=\"text-white text-2xl font-bold\">Press Start to Play</div>\n            </div>\n          )}\n        </div>\n\n        <div className=\"mt-4 flex gap-4\">\n          <button\n            onClick={resetGame}\n            className=\"px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700\"\n          >\n            {isGameOver ? 'Play Again' : 'Start Game'}\n          </button>\n          <button\n            onClick={() => setIsMultiplayer(!isMultiplayer)}\n            className=\"px-4 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700\"\n          >\n            {isMultiplayer ? 'Switch to Single Player' : 'Switch to Multiplayer'}\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default SnakeGame;